### Local Variable Passthrough

[Tasker 5.9.3.beta.6](https://www.reddit.com/r/tasker/comments/gm3dl6/dev_tasker_593beta6_tasker_veterans_rejoice/) introduced new features that allows parent tasks to send all or some of their local variables to child tasks they run and also allows child tasks to send all or some of their local variables back to their parent tasks. Previously only `2` variables, namely `%par1` and `%par2` could be sent to child tasks by their parent tasks and only `1` variable could be sent back to the parent tasks by their child tasks. However, this caused problems in situations where you wanted to send more than 2 distinct values to the child task or return more than 1 distinct value to the parent task. You still had to use the available variables/fields to send all the values, this mostly involved using `Variable Split` actions with commas or newlines as splitters or `AutoTools JSON` and `AutoTools Text` related actions to bundle multiple values in the same variable or using global variables. This mostly worked but in certain situations, the distinct values would be so complex or so many that they could not be reliably or easily sent through the limited number of variables available, like in cases where the variable splitter would be part of a variable value itself. This would then involve using complex variable splitters that are unlikely to normally appear in the values itself and hoping they never do. All that trouble is finally over with the new release, Tasker has been redefined!

To allow parent tasks to send all or some of their local variables to child tasks, the `Perform Task` action now has a `Local Variable Passthrough` toggle and a `Limit Passthrough To` field. If the `Local Variable Passthrough` toggle is disabled, then no local variables of the parent task are sent to the child task, other than any variable values defined in the `Parameter 1 (%par1)` or `Parameter 2 (%par2)` fields that are available to child tasks as `%par1` and `%par2` respectively. The `Limit Passthrough To` field only takes effect if the `Local Variable Passthrough` toggle is enabled. If the `Local Variable Passthrough` toggle is enabled and the `Limit Passthrough To` field is empty, then all the local variables of the parent task are sent to the child task and are available with the same name in the child task. Optionally, the user may want to limit and send only specific variables of the parent task to the child task, this can be done by enabling the `Local Variable Passthrough` toggle and defining either a comma separated list of valid Tasker variable names or defining a variable name search pattern in the `Limit Passthrough To` field for variables that should be sent to the child task. Examples for the field are listed below. 

In [Tasker 5.9.3.beta.rc](https://www.reddit.com/r/tasker/comments/i0253r/dev_tasker_593rc_getting_ready_for_public_release/), an `Allow Overwrite Variables` toggle was also added to the `Perform Task` action which controls whether the child task can send variables back to their parent task or not. If it is enabled, only then will the child task will be allowed to replace values of already existing variables of the parent task using the `Local Variable Passthrough` and `Replace On Passthrough` toggles of the `Return` action. If it is disabled, then the child task will not be allowed to change parent task variables. This was needed because the `5.9.3.beta.6` introduced a security and safety risk for the parent task since it previously had no control over whether its variables will be replaced by the child task or not, expectedly or unexpectedly. Now at least the parent task has that control.

To allow child tasks to send all or some of their local variables back to their parent tasks, the `Return` action now has `Local Variable Passthrough` and `Replace On Passthrough` toggles and a `Limit Passthrough To` field. The `Local Variable Passthrough` toggle and the `Limit Passthrough To` field work the same as they do in `Perform Task` action. The `Local Variable Passthrough` toggle enables or disables whether any local variables of the child task should be sent back to the parent task or not, other than the `Value` field of the `Return` action. The `Replace On Passthrough` toggle and the `Limit Passthrough To` field only takes effect if the `Local Variable Passthrough` toggle is enabled. The `Limit Passthrough To` field defines what local variables should be sent back to the parent task. If it is left empty, then all are sent. If a forward slash separated list of valid Tasker variable names or a variable name search pattern is defined, then only those variables are sent back. The `Replace On Passthrough` toggle defines whether the values of variables that are already defined in the parent task are replaced or not if any variables in the child task with the same name are sent back to the parent task. If it is enabled, then all the values of the local variables that are already defined in the parent task will be replaced with the values that existed in the child task for variables that are sent back and any variables that didn't exist in the parent task will be created. If it is disabled, then only those variables that were defined in the parent task will be created in the parent task with the values sent by the child task. Suppose if the parent task has defined a variable named `%variable1` but has not defined a variable named `%variable2` and calls a child task and the child task has the `Limit Passthrough To` field set to `%variable1/%variable2` in the `Return` action. If the `Replace On Passthrough` toggle is enabled, then when control returns back to the parent task, the value of the `%variable1` variable in the parent task will be replaced with the value sent by the child task and a new `%variable2` variable will also be defined in the parent task with the value sent by the child task. If the `Replace On Passthrough` toggle is disabled, then when control returns back to the parent task, the `%variable1` value in the parent task will not be replaced with the value sent by the child task and only a new `%variable2` variable will be defined in the parent task with the value sent by the child task.

If the `Allow Overwrite Variables` toggle is enabled, then the user must make sure that the child task that is run by the parent task is safe and has all the `Return` actions correctly defined to prevent any logically incorrect behavior like in case the parent task is expecting a variable to be normally unset in a later part of the task by default but a child task called with the `Perform Task` action created it and sent it back to the parent task along with other variables without the parent task expecting it.

Moreover, a lot of care must be taken when using the `Limit Passthrough To` field for the `Perform Task` and `Return` actions. It could potentially have devastating effects and would be hard to debug if used incorrectly. Ideally, the field must not be left empty and only the variables that need to be sent to the child task or back to the parent task should be explicitly defined in the field. There could be conflicts between variables used in the parent and child tasks and explicitly defining variables that should be sent makes the code safer and reduces chances of bugs. Imagine running a `For` loop in the parent task with the variable `%num` as the index which calls a child task that also uses the variable `%num` as the index for its own `For` loop. If the child task had `Local Variable Passthrough` and `Replace On Passthrough` enabled in the `Return` action and left the `Limit Passthrough To` field empty, then when the control returns back to the parent, the `%num` variable value in the parent will be replaced with the value it had last in the child task, probably that of the last iteration of the `For` loop in the child task. This could result in logically incorrect behavior in the parent task. Also imagine if the child task expects a certain variable `%variable1` to be unset initially when the task is run and the parent task calls it with the `Local Variable Passthrough` enabled in the `Perform Task` action and `Limit Passthrough To` field empty. If the parent task had already defined the variable `%variable1` and it is sent to the child task, then this could again result in logically incorrect behavior in the child task since it was expecting the variable to be unset initially. There would be a lot of scenarios where sending all or common variables between tasks could be dangerous, hence it is best to send only specific variables between tasks unless it is absolutely necessary to send all of them and the user knows what he is doing. It would be wise for users to use some prefix or suffix like `shared_`, `_shared`, `par_` or `return_` for variables that are being shared between tasks and using pattern matching in the `Limit Passthrough To` field. Firstly, the code would be more readable since it would be clear what variables are being shared between tasks. Secondly, it will make the code safer since it would reduce chances of conflicts. Thirdly, it would make it easier to share variables between tasks since only a variable name pattern matching string could be used in the `Limit Passthrough To` fields instead of having to explicitly define a forward slash separated list and having to update it whenever a new variable needs to be shared. (cr: u/R_G)

### Examples for `Limit Passthrough To` field

The variable names must have the `%` prefix. You can defined the list in 3 ways.

- Forward slash separated variable list of variable names. Example: `%shared_variable1` or `%shared_variable1,%shared_variable2`

- Simple pattern matching like used in `If` `Matches ~` conditions. Example: `%shared_*`

- Regex pattern matching like used in `If` `Matches Regex ~R` conditions. It must start with the prefix `~R` to differentiate it from simple matching. Example: `~R^%shared_.*$`

Check [Pattern Matching](https://tasker.joaoapps.com/userguide/en/matching.html) in Tasker Userguide for more details on matching.


### Reset Return Variable

[Tasker 5.9.3.beta.6](https://www.reddit.com/r/tasker/comments/gm3dl6/dev_tasker_593beta6_tasker_veterans_rejoice/) [sub beta](https://www.reddit.com/r/tasker/comments/gm3dl6/dev_tasker_593beta6_tasker_veterans_rejoice/frr38bx?utm_source=share&utm_medium=web2x) also introduced another feature or more accurately a way to solve a critical bug that has existed for a long time. 

A `Reset Return Variable` toggle has been added to the `Perform Task` action which when enabled will automatically unset any variable defined in the `Return Value Variable` field whenever the action is used to run a child task and the variable will only be set if the child task returns something with a `Return` action. If the toggle is disabled and as per the default for previous versions, the variable defined in the `Return Value Variable` field of the `Perform Task` action will not be automatically unset whether the child task uses a `Return` action or not.

Why this addition was necessary needs some explanation. Suppose `Task 1` calls `Task 2` with a `Perform Task` action. If we set a variable like `%result` in the `Return Value Variable` field of the `Perform Task` action, it does not automatically get unset if the `Task 2` used a `Stop` action, fails with a Java exception or due to collision handling. This is inconsistent with how other actions work, including `Run Shell` where `Output` and `Error` variables get unset automatically if the command didn't output anything. The problem with the default/previous `Perform Task` design is that one needs to manually unset the `%result` variable with the `Variable Clear` action before the `Perform Task` if `Task 2` is called more than once in `Task 1`, sequentially or in a `For` loop or if the same `%result` variable is used in multiple `Perform Task` actions or is already used somewhere else before the `Perform Task` action. This is dangerous in situations where manual clear is not used and the user is checking if the `Task 2` succeeded or not based on the value of `%result` variable. Suppose if `Task 1` calls `Task 2` and it succeeds and `%result` is set to `0` for success, then we call `Task 2` again without manually clearing `%result` variable, and the `Task 2` uses a `Stop` action, then the `%result` variable would not be unset, and when `Task 1` checks if `Task 2` succeeded, it will still see the previously set value `0` and assume call 2 to `Task 2` also succeeded. This could result in unsafe or logically incorrect behavior in the parent task.

It is unclear why the default behavior of result variable not being automatically unset existed in the first place. One of the use case would be that the user passes a variable as a parameter to a child task but wants to keep it as is if the child task does not change it or return anything. There could possibly be other use cases for it as well. For these reasons the default behavior cannot be changed, specially after so many years, considering it could break the tasks of existing users. However, the `Reset Return Variable` toggle is added to the `Perform Task` action so that the users who do not have such use cases and want the result variable to be automatically unset for proper validation checks, without having to add an extra `Variable Clear` action before each `Perform Task` action or wherever required. The addition of the toggle does not affect existing user configurations since the default behavior is the same as previous versions since the toggle is disabled by default.

For users who already have hundreds and thousands of `Perform Task` actions in their configurations and want the result variable to be automatically unset but don't want to manually enable all of their `Perform Task` actions can use the [tasker_config_perform_task_return_variable_toggle_add](https://github.com/agnostic-apollo/Tasker-Random-Stuff/blob/master/tasker_config_perform_task_return_variable_toggle_add/README.md) script to quickly add tags to all their `Perform Task` actions to enable the `Reset Return Variable` toggle in one go in their Tasker Backup XML.

Note that if you enable the `Reset Return Variable` toggle, then in some cases where faulty code is written or if best practices like input validation are not followed in tasks by the user depending on his circumstances, some issues may be brought to the surface, which may be a good thing since now they can be more easily found, debugged and solved.
The user should know that like a lot of actions in Tasker, the `Variable Search Replace` and `Variable Split` actions will fail if the variable passed to them is not set and the task running them will crash, sending nothing back to any parent tasks. The user needs to set up validation checks to ensure that the input variable is valid or at the very least use `If %variable Set` in actions like these so that they are not run and the task continues on without running them, depending on task design. It is basically the user's responsibility to ensure that the tasks are logically correct and have validation checks in place so that the tasks fail gracefully and they optionally warn the user as well.
